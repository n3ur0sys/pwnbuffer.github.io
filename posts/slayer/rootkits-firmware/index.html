<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Rootkits in Firmware Â· pwnbuffer
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="pwnbuffer">
<meta name="description" content="In this paper, we talk abouts what firmware rootkits are and how they operate">
<meta name="keywords" content="team brazuca!">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Rootkits in Firmware">
  <meta name="twitter:description" content="In this paper, we talk abouts what firmware rootkits are and how they operate">

<meta property="og:url" content="https://pwnbuffer.org/posts/slayer/rootkits-firmware/">
  <meta property="og:site_name" content="pwnbuffer">
  <meta property="og:title" content="Rootkits in Firmware">
  <meta property="og:description" content="In this paper, we talk abouts what firmware rootkits are and how they operate">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-05T00:00:00+00:00">
    <meta property="article:tag" content="Rootkit">
    <meta property="article:tag" content="Low Level">
    <meta property="article:tag" content="Malware Analysis">




<link rel="canonical" href="https://pwnbuffer.org/posts/slayer/rootkits-firmware/">


<link rel="preload" href="https://pwnbuffer.org/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://pwnbuffer.org/css/coder.min.b886fe0d9034709648f91f4ce178f51dd367d9350f82dd1132d54fd69bfca66f.css" integrity="sha256-uIb&#43;DZA0cJZI&#43;R9M4Xj1HdNn2TUPgt0RMtVP1pv8pm8=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://pwnbuffer.org/css/coder-dark.min.165f5fe7c98269a5cfc54f81472e0f84ebc32d92bbe6c9db1f06962b0817bda1.css" integrity="sha256-Fl9f58mCaaXPxU&#43;BRy4PhOvDLZK75snbHwaWKwgXvaE=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="https://pwnbuffer.org/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-32x32.ico" sizes="32x32">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-16x16.ico" sizes="16x16">

<link rel="apple-touch-icon" href="https://pwnbuffer.org/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://pwnbuffer.org/images/apple-touch-icon.png">

<link rel="manifest" href="https://pwnbuffer.org/site.webmanifest">
<link rel="mask-icon" href="https://pwnbuffer.org/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://pwnbuffer.org/">
      pwnbuffer
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/members/">Members</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/wallpapers/">Wallpapers</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://pwnbuffer.org/pt-br/posts/slayer/rootkits-firmware/">ðŸ‡§ðŸ‡·</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://pwnbuffer.org/posts/slayer/rootkits-firmware/">
              Rootkits in Firmware
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-03-05T00:00:00Z">
                March 5, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              20-minute read
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/authors/slayer/">Slayer</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/categories/maldev/">Maldev</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/rootkit/">Rootkit</a>
    </span>
      <span class="separator">â€¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/low-level/">Low Level</a>
    </span>
      <span class="separator">â€¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/malware-analysis/">Malware Analysis</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="what-is-a-rootkit">
  What is a Rootkit?
  <a class="heading-link" href="#what-is-a-rootkit">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>A rootkit is a type of malware designed to gain and maintain privileged access to a system while hiding its presence. The term comes from the combination of &ldquo;root&rdquo;, which refers to the user with maximum privileges on Linux systems, and &ldquo;kit&rdquo; which represents a set of tools used to control the compromised system</strong></p>
<p><strong>The main purpose of a rootkit is to ensure persistence, allowing an attacker to continue accessing the system even after reboots or removal attempts. To do this, it modifies critical components of the operating system, such as the kernel, drivers or system services, making it difficult to detect and remove.</strong></p>
<p><strong>The difference between traditional rootkits and firmware rootkits is that traditional rootkits operate in user-mode or kernel-mode, depending on the level of privilege they can obtain. They modify system files, processes or kernel structures to hide themselves and maintain persistent access. Unlike traditional rootkits, firmware rootkits infect hardware firmware such as BIOS, UEFI, network cards, storage controllers, and even GPUs. This means they can persist even after a complete system format, making the infection extremely difficult to remove!</strong></p>
<h1 id="firmware-fundamentals">
  Firmware Fundamentals
  <a class="heading-link" href="#firmware-fundamentals">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>Firmware is a special type of software built directly into a device&rsquo;s hardware. It serves as the bridge between the hardware and the operating systems or software that use it, controlling its basic functioning and ensuring that it operates correctly and efficiently. Unlike conventional software, which can be easily installed or removed, firmware typically resides in non-volatile memory such as ROM, EEPROM, or Flash Memory and is designed to run every time the device is turned on.</strong></p>
<p><strong>Firmware is responsible for defining how hardware works and ensuring that it performs its functions correctly. Without firmware, electronic devices would be unable to operate as they would not have instructions to process commands or interact with other system components. On a computer, for example, the motherboard firmware (such as BIOS or UEFI) has the function of starting all essential components, checking their integrity and loading the operating system. Similarly, on a cell phone, firmware controls communication between the operating system and components such as the screen, sensors, camera and processor.</strong></p>
<h2 id="bios-vs-uefi">
  BIOS VS UEFI
  <a class="heading-link" href="#bios-vs-uefi">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>For decades, computers used BIOS as the motherboard&rsquo;s primary firmware. However, with the advancement of technology, UEFI emerged, which brought significant improvements, such as support for larger disks, faster booting and greater security against malware.</strong></p>
<p><strong>Firmware attacks have become more sophisticated as critical devices have come to rely heavily on this type of software. Firmware rootkits, for example, exploit vulnerabilities in BIOS/UEFI to obtain persistence, becoming practically undetectable and resistant even to system formatting! So, firmware represents a highly strategic target for an attacker for several reasons:</strong></p>
<ul>
<li>
<p><strong>1 - Extreme Persistence: a successful firmware attack can survive operating system reinstallations, formats and even SSD/HD replacements.</strong></p>
</li>
<li>
<p><strong>2 - Difficulty in Detection: most AVs do not check firmware, making these attacks invisible to many protection solutions.</strong></p>
</li>
<li>
<p><strong>3 - Low level of Execution: as the firmware is loaded before the operating system, it can modify the system&rsquo;s behavior without being detected by conventional security mechanisms.</strong></p>
</li>
<li>
<p><strong>4 - Lack of Regular Updates: unlike application software, many firmwares do not receive frequent updates, leaving devices vulnerable for long periods.</strong></p>
</li>
</ul>
<p><strong>The importance of firmware goes far beyond simply allowing the hardware to function correctly. It is one of the most critical components in terms of security and stability, being fundamental for the proper functioning of any computer system. For this reason, attacks targeting firmware represent a growing and complex threat, requiring special attention from both manufacturers and users.</strong></p>
<h2 id="concept-and-operation">
  Concept and Operation
  <a class="heading-link" href="#concept-and-operation">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Firmware rootkits represent an evolution of traditional persistence methods used by attackers. Unlike conventional rootkits, which compromise operating system files or running processes, a firmware rootkit hides in hardware components, making its removal extremely complex.</strong></p>
<p><strong>Because they are at a lower level than the operating system itself, these rootkits can manipulate the environment even before the OS boots, allowing the modification of data in memory, the interception of system calls and even the injection of code into the bootloader.</strong></p>
<p><strong>The big difference between a firmware rootkit is its ability to remain active even after multiple removal attempts. Because it operates at a deeper level than the operating system itself, it survives:</strong></p>
<ul>
<li>
<p><strong>Disk formatting: The firmware resides outside the SSD/HD, so erasing or replacing the storage does not remove the threat.</strong></p>
</li>
<li>
<p><strong>Operating system reinstallation: The rootkit is executed before the OS is loaded and can automatically reinfect it.</strong></p>
</li>
<li>
<p><strong>Component exchange: If the rootkit is in a compromised BIOS/UEFI, changing the HD, RAM or even the GPU does not remove the threat.</strong></p>
</li>
<li>
<p><strong>Poorly implemented firmware updates: Some rootkits modify the firmware update routine, preventing malicious code from being overwritten.</strong></p>
</li>
</ul>
<p><strong>The only definitive solution often involves completely rewriting the firmware through a process called flashing or, in extreme cases, physically replacing the compromised chip.</strong></p>
<h2 id="attack-vectors">
  Attack Vectors
  <a class="heading-link" href="#attack-vectors">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>To compromise a system&rsquo;s firmware, attackers use different infection techniques, exploiting both known vulnerabilities and flaws in the hardware security chain. Some of the most common methods include:</strong></p>
<ul>
<li>
<p><strong>1 - Exploitation of Vulnerabilities in UEFI/BIOS: Some firmware versions have flaws that allow arbitrary execution of malicious code. Attackers can exploit these vulnerabilities to inject rootkits directly into the firmware.</strong></p>
</li>
<li>
<p><strong>2 - Malicious Firmware Updates: If an attacker compromises a manufacturer&rsquo;s update server (supply chain attack) or tricks the user into installing a fake update, he can replace the legitimate firmware with a modified one.</strong></p>
</li>
<li>
<p><strong>3 - Attacks via Compromised Hardware Components: Motherboards, USB devices and even peripherals can come from the factory with altered firmware. This has already occurred with tampered HDs and SSDs that installed malware on the system as soon as they were connected.</strong></p>
</li>
<li>
<p><strong>4 - Remote Attacks on Connected Devices: In some cases, rootkits can be injected remotely by exploiting vulnerabilities in hardware management interfaces, such as the Intel Management Engine (IME) or the Baseboard Management Controller (BMC).</strong></p>
</li>
<li>
<p><strong>5 - Physical Attacks and Evil Maid Attack: An attacker with physical access to the device can use techniques such as SPI flashing to directly overwrite the BIOS/UEFI firmware, installing a rootkit in a practically undetectable way.</strong></p>
</li>
</ul>
<h3 id="biosuefi">
  BIOS/UEFI
  <a class="heading-link" href="#biosuefi">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>BIOS and UEFI are the first software components executed when turning on a computer, being responsible for initializing the hardware and loading the operating system. Because of this privileged position in the boot chain, modifying the BIOS/UEFI firmware is one of the most effective ways to ensure system persistence.</strong>
<strong>The process of injecting a rootkit into the BIOS or UEFI can be done in the following ways:</strong></p>
<ul>
<li>
<p><strong>1 - Firmware Rewrite with Malicious Code:</strong></p>
<ul>
<li><strong>The attacker obtains a copy of the device&rsquo;s original firmware and modifies it, inserting malicious code that will be executed during boot.</strong></li>
<li><strong>The tampered firmware is then reinstalled on the device, replacing the legitimate version. This process can be carried out manually, if the attacker has physical access to the hardware, or remotely, exploiting update vulnerabilities.</strong></li>
</ul>
</li>
<li>
<p><strong>2 - ACPI Table Manipulation (Advanced Configuration and Power Interface)</strong></p>
<ul>
<li><strong>ACPI manages communication between the firmware and the operating system. By altering ACPI tables within UEFI, a rootkit can inject malicious code that will be loaded directly into memory during boot.</strong></li>
<li><strong>This method is particularly effective because code executed by ACPI is not constantly checked by the operating system and can be modified without alerting conventional security tools.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Firmware Call Intercept</strong></p>
<ul>
<li><strong>A rootkit can modify boot functions within the BIOS/UEFI, redirecting calls to malicious code. This allows the malware to have control over the system from the first moments of startup. Once installed, a firmware rootkit can modify the operating system&rsquo;s loading, inject malware directly into RAM, or even automatically reinstall malicious files on the hard drive after formatting attempts.</strong></li>
</ul>
</li>
</ul>
<h3 id="vulnerabilities-in-signed-drivers-and-firmware">
  Vulnerabilities in Signed Drivers and Firmware
  <a class="heading-link" href="#vulnerabilities-in-signed-drivers-and-firmware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Many modern devices use digitally signed firmware to ensure authenticity. However, attackers often exploit vulnerabilities in these firmwares to inject malicious code without having to directly modify the BIOS or UEFI.</strong></p>
<ul>
<li>
<p><strong>1 - Use of Drivers with Known Vulnerabilities</strong></p>
<ul>
<li><strong>Some hardware drivers, especially those signed by manufacturers, may contain flaws that allow privileged code to execute. If a vulnerable driver is installed on the system, an attacker can exploit it to write directly to the firmware memory.</strong></li>
<li><strong>A practical example of this attack was the use of overclocking drivers that allowed access to critical regions of memory, enabling firmware modification without needing administrative privileges.</strong></li>
</ul>
</li>
<li>
<p><strong>2 - Abuse of Firmware Update Mechanisms</strong></p>
<ul>
<li><strong>Many manufacturers offer tools that allow automatic updating of system firmware. If an attacker compromises these tools or injects malicious code into the update process, they can install a rootkit without directly modifying the original firmware.</strong></li>
<li><strong>In some cases, downgrade attacks may be used, where old firmware (with known vulnerabilities) is reinstalled, allowing a known exploit to be used to compromise the system.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Attacks on the TPM Module and Intel ME</strong></p>
<ul>
<li><strong>The <strong>Intel Management Engine (ME)</strong> and <strong>Trusted Platform Module (TPM)</strong> are hardware components designed to ensure firmware and operating system integrity. However, vulnerabilities in these modules have already been exploited to compromise the secure boot of the system.</strong></li>
<li><strong>Once a rootkit is injected at this layer, it can communicate directly with the firmware, modifying critical processes before the operating system has a chance to detect the threat.</strong></li>
</ul>
</li>
</ul>
<h3 id="malicious-firmware-update">
  Malicious Firmware Update
  <a class="heading-link" href="#malicious-firmware-update">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Firmware update processes generally involve replacing code stored in the device&rsquo;s Flash memory. If an attacker compromises this process, they can install a rootkit in a virtually undetectable manner.</strong></p>
<ul>
<li>
<p><strong>1 - Compromise of Update Servers</strong></p>
<ul>
<li><strong>Some companies distribute firmware updates through online servers. If an attacker compromises these servers, they can distribute tampered versions of the firmware to thousands of devices at once.</strong></li>
<li><strong>This type of attack has already been observed in supply chain attacks, where manufacturers have been compromised and distributed malicious firmware without realizing it.</strong></li>
</ul>
</li>
<li>
<p><strong>2 - &ldquo;Evil Maid&rdquo; Attacks and Physical Firmware Modification</strong></p>
<ul>
<li><strong>If an attacker has physical access to the device, they can directly replace the original firmware with a modified version using techniques such as SPI flashing</strong>.</li>
<li><strong>This method allows the rootkit to be installed even on protected systems, as the firmware can be rewritten using reverse engineering tools.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Use of Malicious Bootloaders</strong></p>
<ul>
<li><strong>A rootkit can be installed through a fake bootloader update, which is responsible for loading the operating system. If an attacker modifies the bootloader, they can intercept the boot process and ensure that the malware is executed before the operating system is loaded.</strong></li>
</ul>
</li>
</ul>
<h3 id="bootkits--secure-boot-attacks">
  Bootkits &amp; Secure Boot Attacks
  <a class="heading-link" href="#bootkits--secure-boot-attacks">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Bootkits are a category of rootkits that install themselves in the system&rsquo;s boot chain, modifying the bootloader or critical files responsible for loading the operating system. One of the main barriers against these attacks is <strong>Secure Boot</strong>, a mechanism that prevents unsigned code from executing during boot. However, there are methods to bypass this protection.</strong></p>
<ul>
<li>
<p><strong>1 - Forced Disable Secure Boot</strong></p>
<ul>
<li><strong>Some firmwares allow Secure Boot to be manually disabled in BIOS/UEFI. If an attacker gains access to the firmware, they can disable this protection and allow malicious code to execute during boot.</strong></li>
</ul>
</li>
<li>
<p><strong>2 - Use of Compromised Certificates</strong></p>
<ul>
<li><strong>Secure Boot relies on a chain of digital signatures to verify the authenticity of loaded code. If an attacker is able to use a valid signing key (for example, by exploiting a compromised certificate from a manufacturer), they can inject malicious code without triggering security alerts.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Attacks on Vulnerable Bootloaders</strong></p>
<ul>
<li><strong>Some older bootloaders have flaws that allow unsigned code to run. If an attacker can force the system to load a vulnerable bootloader, they can inject a bootkit that will load before the operating system.</strong></li>
</ul>
</li>
</ul>
<h2 id="real-examples-of-rootkits-in-firmware">
  Real Examples of Rootkits in Firmware
  <a class="heading-link" href="#real-examples-of-rootkits-in-firmware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Firmware rootkits are not just a theoretical threat. There are records of real attacks in which rootkits compromised systems at the firmware level, ensuring extreme persistence and making their detection and removal difficult. And here are three emblematic cases that demonstrate the sophistication of these threats.</strong></p>
<h3 id="lojax-the-first-known-rootkit-for-uefi">
  <strong>LoJax: The First Known Rootkit for UEFI</strong>
  <a class="heading-link" href="#lojax-the-first-known-rootkit-for-uefi">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>LoJax was the first UEFI firmware rootkit detected in a real attack, being identified by security company ESET in 2018. It was attributed to the APT28 (Fancy Bear) hacker group, linked to Russian intelligence, and used mainly in attacks against government targets and high-value organizations.</strong></p>
<h4 id="operation-of-lojax">
  <strong>Operation of LoJax</strong>
  <a class="heading-link" href="#operation-of-lojax">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>LoJax exploited vulnerabilities in UEFI firmware to install itself directly into the motherboard&rsquo;s SPI Flash. Its goal was to ensure full persistence, allowing attackers to maintain access to the system even after formatting or replacing the hard drive.</strong></p>
<p><strong>The attack happened in stages:</strong></p>
<ul>
<li>
<p><strong>1 - Initial Commitment</strong></p>
<ul>
<li><strong>The attacker first infected the machine through conventional methods, such as phishing or exploiting vulnerabilities in the operating system.</strong></li>
<li><strong>Once inside the system, the malware identified whether the UEFI firmware was protected from modification (some motherboards allow the firmware to be rewritten without needing special permissions).</strong></li>
</ul>
</li>
<li>
<p><strong>2 - UEFI Firmware Dump</strong></p>
<ul>
<li><strong>LoJax used tools to extract a copy of legitimate UEFI firmware, analyzing its structure.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Modification and Rewriting</strong></p>
<ul>
<li><strong>The rootkit injected a malicious module into the UEFI, ensuring that it was executed on every boot.</strong></li>
<li><strong>The modified firmware was then rewritten to the motherboard&rsquo;s SPI Flash, replacing the original version.</strong></li>
</ul>
</li>
<li>
<p><strong>4 - Persistence and Communication</strong></p>
<ul>
<li><strong>Whenever the computer was turned on, LoJax activated its code before loading the operating system, being able to reinstall malware in the OS or manipulate boot settings.</strong></li>
<li><strong>It also used hidden channels to communicate with attackers, enabling remote control of the infected system.</strong></li>
</ul>
</li>
</ul>
<h4 id="impact--detection">
  <strong>Impact &amp; Detection</strong>
  <a class="heading-link" href="#impact--detection">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>LoJax demonstrated that persistent attacks against UEFI were viable and difficult to mitigate. Its detection required advanced firmware analysis techniques, as the rootkit operated at a level invisible to traditional antiviruses. As the malicious code was recorded in the SPI Flash, the only definitive solution was to completely rewrite the firmware or replace the motherboard.</strong></p>
<h3 id="moonbounce-rootkit-in-firmware-detected-by-kaspersky">
  <strong>MoonBounce: Rootkit in Firmware Detected by Kaspersky</strong>
  <a class="heading-link" href="#moonbounce-rootkit-in-firmware-detected-by-kaspersky">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>MoonBounce was identified in 2022 by Kaspersky as one of the most sophisticated firmware rootkits ever seen. Attributed to the China-linked hacker group APT41, it exploited UEFI to ensure persistence and execute malicious payloads directly from firmware memory.</strong></p>
<h4 id="moonbounce-differences">
  MoonBounce differences
  <a class="heading-link" href="#moonbounce-differences">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>MoonBounce stood out from previous rootkits because it operated more discreetly and efficiently:</strong></p>
<ul>
<li><strong>Code injected directly into PEI (Pre-EFI Initialization) memory: This allowed the rootkit to be executed without having to modify the bootloader or kernel.</strong></li>
<li><strong>Lightweight and modular payload: Unlike other rootkits that injected large amounts of code, MoonBounce used minimal code to maintain its presence, reducing chances of detection.</strong></li>
<li><strong>Persistence without modifying files on the disk: The code was loaded directly by the firmware and injected into the operating system&rsquo;s memory without having to create files on the hard disk.</strong></li>
</ul>
<h4 id="how-the-attack-works">
  How the Attack Works
  <a class="heading-link" href="#how-the-attack-works">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ul>
<li><strong>1 - The attacker compromised the system and gained administrative-level access.</strong></li>
<li><strong>2 - Using specialized tools, the rootkit was injected directly into the UEFI memory.</strong></li>
<li><strong>3 - During system startup, malicious code was loaded before the operating system, allowing it to communicate with command and control (C2) servers and execute new instructions.</strong></li>
</ul>
<h4 id="impact-and-complexity">
  Impact and Complexity
  <a class="heading-link" href="#impact-and-complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>MoonBounce demonstrated how firmware rootkits were evolving to be even more stealthy. Because it operated completely in memory during the boot phase, detection required detailed firmware analysis, making mitigation an even greater challenge.</strong></p>
<h3 id="mebromi-rootkit-that-infected-award-bios">
  Mebromi: Rootkit that Infected Award BIOS
  <a class="heading-link" href="#mebromi-rootkit-that-infected-award-bios">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Mebromi was one of the first rootkits to compromise conventional BIOS firmware, having been identified in 2011. Unlike sophisticated attacks on UEFI, Mebromi targeted BIOS from the manufacturer Award, one of the most popular at the time.</strong></p>
<h4 id="how-mebromi-works">
  How Mebromi works
  <a class="heading-link" href="#how-mebromi-works">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>Mebromi was a hybrid rootkit, combining components for BIOS, MBR (Master Boot Record) and Windows. The attack followed these steps:</strong></p>
<ul>
<li>
<p><strong>1 - BIOS Firmware Injection</strong></p>
<ul>
<li><strong>If the machine had a vulnerable BIOS Award, the rootkit modified the firmware, guaranteeing its execution at each boot.</strong></li>
</ul>
</li>
<li>
<p><strong>2 - Modification of the MBR (Master Boot Record)</strong></p>
<ul>
<li><strong>The rootkit altered the hard drive&rsquo;s boot sector to load malicious code before loading the operating system.</strong></li>
</ul>
</li>
<li>
<p><strong>3 - Windows Compromise</strong></p>
<ul>
<li><strong>After Windows booted, Mebromi injected additional malware into the system, allowing the attacker remote control.</strong></li>
</ul>
</li>
<li>
<p><strong>4 - Self-reinstallation</strong></p>
<ul>
<li><strong>Even if the malware was removed from the operating system, the infected BIOS automatically reinstalled the malicious files, ensuring persistence.</strong></li>
</ul>
</li>
</ul>
<h4 id="impact-and-limitations">
  <strong>Impact and Limitations</strong>
  <a class="heading-link" href="#impact-and-limitations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>Although Mebromi was innovative at the time, its action was limited to systems that used BIOS Award and ran Windows. However, it demonstrated how firmware modification could be used to create highly persistent attacks.</strong></p>
<h2 id="detect-rootkits-in-firmware">
  Detect Rootkits in Firmware
  <a class="heading-link" href="#detect-rootkits-in-firmware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Detecting rootkits in firmware is a major challenge, as these threats operate at an extremely low level of the system, often leaving no traces detectable by traditional antiviruses. Because firmware runs before the operating system, a well-designed rootkit can modify system startup without raising suspicion.</strong></p>
<p><strong>Therefore, identifying these threats requires the use of specialized tools, detailed analysis of the integrity of the firmware and the observation of anomalies that may indicate compromise.</strong></p>
<h2 id="firmware-analysis-tools">
  Firmware Analysis Tools
  <a class="heading-link" href="#firmware-analysis-tools">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>There are some tools specifically designed to analyze BIOS/UEFI firmware and embedded devices. They allow you to extract, modify and verify the integrity of the firmware, being essential for identifying rootkits.</strong></p>
<h3 id="chipsec">
  CHIPSEC
  <a class="heading-link" href="#chipsec">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>CHIPSEC is one of the most used frameworks for firmware security analysis, developed by Intel. It allows:</strong></p>
<ul>
<li><strong>Analyze the integrity of SPI Flash to check for unauthorized modifications.</strong></li>
<li><strong>Check write permissions on the firmware, identifying whether write protection has been disabled by a rootkit.</strong></li>
<li><strong>Review UEFI security settings such as Secure Boot and Boot Guard configuration.</strong></li>
</ul>
<h3 id="uefitool">
  UEFITool
  <a class="heading-link" href="#uefitool">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>UEFITool is a powerful tool for reverse engineering UEFI firmware. With it, you can:</strong></p>
<ul>
<li><strong>Extract and view individual modules within the firmware.</strong></li>
<li><strong>Identify possible injections of malicious code.</strong></li>
<li><strong>Modify and rebuild UEFI firmware (useful for research, but dangerous in real environments).</strong></li>
</ul>
<h3 id="binwalk">
  Binwalk
  <a class="heading-link" href="#binwalk">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Binwalk is a widely used firmware analysis tool for embedded devices. It allows:</strong></p>
<ul>
<li><strong>Identify and extract specific firmware sections.</strong></li>
<li><strong>Look for patterns that indicate the presence of hidden malicious code.</strong></li>
</ul>
<p><em>In addition to these tools, some manufacturers provide their own firmware integrity checkers, such as Windows Defender System Guard and utilities from Intel, AMD and Dell.</em></p>
<h2 id="memory-analysis-and-firmware-integrity">
  Memory Analysis and Firmware Integrity
  <a class="heading-link" href="#memory-analysis-and-firmware-integrity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>An effective approach to detecting rootkits in firmware involves checking the integrity of the code stored in the motherboard&rsquo;s SPI Flash and analyzing the memory while the system is running.</strong></p>
<h3 id="firmware-dump-and-comparison">
  Firmware Dump and Comparison
  <a class="heading-link" href="#firmware-dump-and-comparison">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>One technique used by security researchers is to extract a copy of the SPI Flash firmware and compare it with the official version provided by the manufacturer. This can be done with tools like CHIPSEC and Flashrom. If discrepancies are found, it is a strong indication that the firmware has been modified.</strong></p>
<h3 id="volatile-memory-analysis">
  Volatile Memory Analysis
  <a class="heading-link" href="#volatile-memory-analysis">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Some rootkits only operate on the firmware memory during boot, without permanently modifying the files in the SPI Flash. To detect this behavior, you can use memory forensics techniques, such as:</strong></p>
<ul>
<li><strong>RAM dump during boot and compared to a clean boot.</strong></li>
<li><strong>Monitoring firmware calls to identify injected malicious code.</strong></li>
</ul>
<h3 id="uefi-integrity-check">
  <strong>UEFI Integrity Check</strong>
  <a class="heading-link" href="#uefi-integrity-check">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Specialized tools, such as Microsoft Defender ATP, offer automatic UEFI checks to detect suspicious modifications. Some manufacturers also include internal protection mechanisms, such as:</strong></p>
<ul>
<li><strong>Boot Guard (Intel) prevents firmware modification at boot.</strong></li>
<li><strong>AMD PSP verifies firmware integrity on select AMD processors.</strong></li>
</ul>
<h2 id="signs-of-infection-and-system-anomalies">
  <strong>Signs of Infection and System Anomalies</strong>
  <a class="heading-link" href="#signs-of-infection-and-system-anomalies">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Although firmware rootkits are highly stealthy, some signs may indicate their presence:</strong></p>
<h4 id="1-unexplained-boot-changes">
  1. Unexplained Boot Changes
  <a class="heading-link" href="#1-unexplained-boot-changes">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ul>
<li><strong>The operating system boots with unexpected settings.</strong></li>
<li><strong>Change of boot order without user intervention.</strong></li>
<li><strong>Secure Boot disabled for no apparent reason.</strong></li>
</ul>
<h4 id="2-abnormal-persistence-of-malware">
  2. Abnormal Persistence of Malware
  <a class="heading-link" href="#2-abnormal-persistence-of-malware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ul>
<li><strong>Malware that reappears even after complete formatting and system reinstallations.</strong></li>
<li><strong>Suspicious files being recreated shortly after deletion.</strong></li>
</ul>
<h4 id="3-anomalies-in-hardware-devices">
  3. Anomalies in Hardware Devices
  <a class="heading-link" href="#3-anomalies-in-hardware-devices">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ul>
<li><strong>Network card, GPU or other hardware working strangely.</strong></li>
<li><strong>System logs showing unexpected access to hardware controllers.</strong></li>
</ul>
<h4 id="4-suspicious-communication">
  4. Suspicious Communication
  <a class="heading-link" href="#4-suspicious-communication">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ul>
<li><strong>Network traffic to unknown addresses even before the operating system loads.</strong></li>
<li><strong>Connections established with remote servers without visible processes on the system.</strong></li>
</ul>
<p><em>Ultimately, the use of tools such as <strong>CHIPSEC, UEFITool &amp; Binwalk</strong>, combined with memory forensic analysis and system anomaly monitoring, can help identify the presence of these rootkits before they cause irreversible damage.</em></p>
<h1 id="development-of-rootkits-in-firmware">
  Development of Rootkits in Firmware
  <a class="heading-link" href="#development-of-rootkits-in-firmware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>The development of firmware rootkits is a highly specialized field within offensive security, requiring in-depth knowledge of firmware architecture, reverse engineering and code injection techniques in embedded systems. Unlike conventional rootkits, which operate in the kernel or user space, firmware rootkits act directly on hardware, ensuring extreme persistence and advanced evasion.</strong></p>
<h2 id="necessary-environment-for-research-and-development">
  <strong>Necessary Environment for Research and Development</strong>
  <a class="heading-link" href="#necessary-environment-for-research-and-development">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Before developing or analyzing rootkits in firmware, a suitable environment is required, including a retoolkit, development kits, and testing devices.</strong></p>
<h3 id="1-tools-and-frameworks">
  1. Tools and Frameworks
  <a class="heading-link" href="#1-tools-and-frameworks">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>UEFI Development Kit (UDK): Official framework for developing UEFI firmwares.</strong></li>
<li><strong>TianoCore: Open-source UEFI implementation used to understand its architecture.</strong></li>
<li><strong>CHIPSEC: Security audit and analysis tool for firmware.</strong></li>
<li><strong>UEFITool: Used for extracting, modifying and reinserting UEFI firmware modules.</strong></li>
<li><strong>IDA Pro / Ghidra: Disassemblers used to reverse engineer compiled firmware.</strong></li>
<li><strong>QEMU with OVMF: Emulator to test UEFI firmwares without the need for physical hardware.</strong></li>
<li><strong>Binwalk &amp; Firmwalker: Analysis and extraction of firmware from embedded devices.</strong></li>
</ul>
<h3 id="2-testing-hardware">
  2. Testing Hardware
  <a class="heading-link" href="#2-testing-hardware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>Motherboards with SPI Flash accessible for writing and modifying BIOS/UEFI.</strong></li>
<li><strong>SPI programmers such as Bus Pirate or CH341A for reading and writing directly to the firmware.</strong></li>
<li><strong>Network cards and storage controllers vulnerable to code injections.</strong></li>
</ul>
<h2 id="firmware-reverse-engineering">
  Firmware Reverse Engineering
  <a class="heading-link" href="#firmware-reverse-engineering">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>To develop a firmware rootkit, the first step is to understand its structure and identify possible injection vectors. This involves extracting and analyzing firmware, disassembling binary code, and identifying modifiable areas.</strong></p>
<h3 id="1-firmware-extraction-and-analysis">
  1. Firmware Extraction and Analysis
  <a class="heading-link" href="#1-firmware-extraction-and-analysis">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Firmware can be extracted from the motherboard&rsquo;s SPI Flash or directly from manufacturer-supplied update files:</strong></p>
<ul>
<li><strong>Firmware reading via SPI using a physical programmer.</strong></li>
<li><strong>Firmware extraction from memory dumps (RAM).</strong></li>
<li><strong>Decompression of firmware images with Binwalk.</strong></li>
</ul>
<p><strong>After extraction, the firmware can be analyzed in tools such as IDA Pro or Ghidra to identify critical functions and modules subject to code injection.</strong></p>
<h3 id="2-identification-of-boot-modules">
  2. Identification of Boot Modules
  <a class="heading-link" href="#2-identification-of-boot-modules">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>In UEFI, rootkits typically inject themselves into DXE (Driver Execution Environment) modules, which run before the operating system and can modify its startup. Some common targets are:</strong></p>
<ul>
<li><strong>DXE Core: Code responsible for executing UEFI drivers.</strong></li>
<li><strong>Boot Services: Temporary services used at boot, but which can persist if handled correctly.</strong></li>
<li><strong>Runtime Services: Maintain access to the operating system even after boot.</strong></li>
</ul>
<p><strong>After identifying the modifiable points, the next step is code injection.</strong></p>
<h2 id="code-injection-in-uefi-and-bios">
  <strong>Code Injection in UEFI and BIOS</strong>
  <a class="heading-link" href="#code-injection-in-uefi-and-bios">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Code injection into firmware can be done in several ways, depending on the protection present in the system.</strong></p>
<h3 id="1-valid-firmware-modification">
  1. Valid Firmware Modification
  <a class="heading-link" href="#1-valid-firmware-modification">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>A common approach is to directly modify an original firmware by inserting malicious payloads into existing modules. This can be done with:</strong></p>
<ul>
<li><strong>UEFITool for modifying DXE modules and adding persistent code.</strong></li>
<li><strong>Manual editing of ACPI or SMBIOS tables to hide malicious code.</strong></li>
<li><strong>Insertion of backdoors in Runtime Services to ensure continuous access to the system.</strong></li>
</ul>
<p><strong>After modification, the firmware is rewritten to SPI Flash, replacing the original.</strong></p>
<h3 id="2-exploiting-vulnerabilities-in-signed-firmware">
  2. Exploiting Vulnerabilities in Signed Firmware
  <a class="heading-link" href="#2-exploiting-vulnerabilities-in-signed-firmware">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>On systems that require digitally signed firmware, it is possible to exploit vulnerabilities such as:</strong></p>
<ul>
<li><strong>Bypass signature checks on poorly protected firmware.</strong></li>
<li><strong>Downgrade attacks, where vulnerable old firmware is installed to allow code injection.</strong></li>
<li><strong>NVRAM variable manipulation to modify critical UEFI settings without changing firmware directly.</strong></li>
</ul>
<p><strong>These techniques allow rootkits to infect systems even without physical access to the hardware.</strong></p>
<h2 id="persistence-and-stealth-in-firmware-rootkits">
  <strong>Persistence and Stealth in Firmware Rootkits</strong>
  <a class="heading-link" href="#persistence-and-stealth-in-firmware-rootkits">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="1-persistence-through-bootkits">
  1. Persistence through Bootkits
  <a class="heading-link" href="#1-persistence-through-bootkits">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>A bootkit modifies the system boot process to ensure that the rootkit is executed before the operating system loads. This can be done by:</strong></p>
<ul>
<li><strong>Replacement of Boot Manager in UEFI firmware.</strong></li>
<li><strong>Modified boot chain to intercept OS loading.</strong></li>
<li><strong>Use of corrupted Root of Trust, where a malicious signed firmware is accepted as legitimate.</strong></li>
</ul>
<h3 id="2-detection-evasion">
  2. Detection Evasion
  <a class="heading-link" href="#2-detection-evasion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>To avoid detection by analysis tools, firmware rootkits use techniques such as:</strong></p>
<ul>
<li><strong>Modification of SPI Flash at runtime, preventing analysis tools from detecting changes.</strong></li>
<li><strong>System call interception, hiding firmware change logs.</strong></li>
<li><strong>Use of malicious Runtime Services to periodically reinfect the operating system.</strong></li>
</ul>
<h3 id="3-survivability-of-firmware-updates">
  <strong>3. Survivability of Firmware Updates</strong>
  <a class="heading-link" href="#3-survivability-of-firmware-updates">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Even if the user tries to remove a rootkit by updating the firmware, some techniques can guarantee persistence:</strong></p>
<ul>
<li><strong>Modification of SPI Flash permissions preventing legitimate firmware rewriting.</strong></li>
<li><strong>Backup malicious code on secondary devices (network cards, storage controllers) to reinfect BIOS/UEFI after update.</strong></li>
<li><strong>Use of vulnerabilities in the update process to inject code during firmware rewriting.</strong></li>
</ul>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2025
     pwnbuffer 
    Â·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder (modified)</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://pwnbuffer.org/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
